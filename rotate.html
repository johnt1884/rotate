<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thumbnail Generator</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            background-color: #EBEBEB;
            color: #ffffff;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .main-container {
            display: flex;
            height: 100%;
        }
        .sidebar {
            width: 200px;
            padding: 0;
            border-right: 1px solid #444444;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
            position: relative; /* Needed for the resizer */
        }

        #sidebar-resizer {
            position: absolute;
            top: 0;
            right: -5px; /* Positioned slightly outside the border */
            width: 10px;
            height: 100%;
            cursor: col-resize;
            z-index: 100;
        }
        #sidebar-scroll-container {
            flex-grow: 1;
            overflow-y: auto;
            height: 0;
            text-align: left;
        }
        .sidebar-section h4, .sidebar-subcategory h5, #sidebar-scroll-container h4, #sidebar-scroll-container h5, #sidebar-scroll-container h6 {
            color: black;
            margin: 10px 0 5px 8px;
            cursor: pointer;
            user-select: none;
            padding: 2px 4px;
            text-align: left;
        }
        .sidebar-subcategory h5 {
            margin-left: 16px;
        }
        .sidebar-buttons {
            display: flex;
            height: 36px;
        }
        .sidebar-cog-btn {
            width: 100%;
            height: 36px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 8px;
            box-sizing: border-box;
        }
        .sidebar-cog-btn:hover {
            background-color: #166fe5;
        }
        #load-directory-btn {
            flex: 1;
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        #load-directory-btn:hover {
            background-color: #166fe5;
        }
        .modal-content button, #last-dir-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 8px;
            cursor: pointer;
            box-sizing: border-box;
        }
        .modal-content button:hover {
            background-color: #166fe5;
        }
        #directory-picker {
            display: none;
        }
        .main-content {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        .top-bar {
            padding: 10px 20px 10px 0px;
            border-bottom: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
        }
        .bottom-bar {
            padding: 10px 10px 10px 0px;
            border-top: 1px solid #444444;
            display: flex;
            align-items: center;
            height: 36px; /* Match button height */
            box-sizing: border-box;
            background-color: #1877f2;
            color: white;
            justify-content: space-between;
        }
        .top-bar label {
            margin-right: 10px; /* Add padding between label and dropdown */
        }
        #thumbnail-container {
            flex-grow: 1;
            padding: 20px;
            position: relative;
            overflow: auto;
        }
        .thumbnail {
            object-fit: cover;
            border-radius: 6px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            cursor: move;
        }
        .thumbnail-placeholder {
            background-color: #e0e0e0;
            border: 2px dashed #cccccc;
            border-radius: 6px;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            padding-top: 60px;
        }
        .modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 680px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
        }
        @keyframes fadeIn {
            from {opacity: 0;}
            to {opacity: 1;}
        }
        .close {
            color: #606770;
            float: right;
            font-size: 32px;
            font-weight: bold;
            line-height: 1;
        }
        .close:hover,
        .close:focus {
            color: #1c1e21;
            text-decoration: none;
            cursor: pointer;
        }
        #batch-script {
            width: 100%;
            box-sizing: border-box;
            border-radius: 6px;
            border: 1px solid #ccd0d5;
            padding: 8px;
            font-family: "Courier New", Courier, monospace;
            margin-top: 8px;
            margin-bottom: 12px;
            resize: vertical;
        }
        #selection-box {
            position: absolute;
            border: 2px dashed #007bff;
            background-color: rgba(0, 123, 255, 0.2);
            pointer-events: none;
            display: none;
            z-index: 2147483647;
        }
        .landscape-row.selected-landscape {
            outline: 3px solid blue;
        }
        .landscape-row.selected-landscape-rotate {
            outline: 3px solid green;
        }
        .landscape-row.selected-delete {
            outline: 3px dashed purple;
        }
        .landscape-row.selected-edit {
            outline: 3px solid yellow;
        }
        .thumbnail-wrapper {
            display: inline-block;
            vertical-align: top;
            text-align: center;
        }
        .thumbnail-name {
            font-size: 12px;
            color: black;
            background-color: #EBEBEB;
            padding: 2px;
            word-wrap: break-word;
            max-width: 256px; /* Match default thumbnail width */
            display: none; /* Hidden by default */
        }
        .thumbnail-wrapper.selected .thumbnail {
            box-shadow: 0 0 0 3px #007bff, 0 4px 8px rgba(0,0,0,0.4);
        }

        #multi-select-btn.active {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        #video-overlay {
            position: absolute;
            top: 37px; /* Height of top-bar */
            left: 200px; /* Width of sidebar */
            right: 0;
            bottom: 50%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #video-player-container {
            position: relative;
            width: 80%;
            height: 80%;
        }

        #video-player {
            width: 100%;
            height: 100%;
        }

        #video-close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            cursor: pointer;
            background: #fff;
            border: none;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            font-size: 16px;
        }

        #video-prev-btn, #video-next-btn {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            background: #fff;
            border: none;
            font-size: 24px;
            padding: 10px;
        }

        #video-prev-btn {
            left: 10px;
        }

        #video-next-btn {
            right: 10px;
        }

        /* Style for dropdown menus to match button height */
        select {
            height: 36px;
            padding: 0 8px 0 8px;
            padding-right: 32px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            text-align: center;
            appearance: none;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6,9 12,15 18,9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat;
            background-position: right 8px center;
            background-size: 16px;
        }

        #size-selector {
            padding: 0 8px 0 8px;
            padding-right: 32px;
        }

        select:focus {
            outline: none;
            border-color: #166fe5;
        }

        select option {
            padding: 8px 12px;
            background-color: #ffffff;
            color: #000000;
            text-align: center;
        }

        select option:nth-child(even) {
            background-color: #f2f2f2;
        }

        /* Style for top-bar buttons */
        .top-bar button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        .top-bar button:hover {
            background-color: #166fe5;
        }

        .top-bar button:disabled {
            background-color: #666666;
            cursor: not-allowed;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }

        #landscape-buttons button:hover {
            background-color: #166fe5;
        }

        #landscape-buttons button:not(:first-child) {
            border-left: none;
        }

        #landscape-buttons button {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            white-space: nowrap;
            cursor: pointer;
        }


        /* Style for layout name input */
        #layout-name-input {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
            margin-right: 0;
            width: 120px;
        }

        #layout-name-input:focus {
            outline: none;
            border-color: #166fe5;
        }

        #layout-name-input::placeholder {
            color: #ffffff;
            opacity: 0.7;
        }

        .dropdown {
            position: relative;
            height: 100%;
        }

        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #ffffff;
            color: #000000;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
        }

        .dropdown-content a {
            color: #000000;
            padding: 12px 16px;
            text-decoration: none;
            display: block;
        }

        .dropdown-content a:nth-child(even) {
            background-color: #f2f2f2;
        }

        .dropdown-content a:hover {background-color: #f1f1f1;}

        .nested-dropdown {
            position: relative;
        }

        .nested-dropdown-content {
            display: none;
            position: absolute;
            left: 100%;
            top: 0;
            background-color: #ffffff;
            min-width: 160px;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        }

        .sidebar-section button.selected-for-removal,
        #sidebar-scroll-container button.selected-for-removal {
            background-color: #d93025 !important;
            color: #ffffff !important;
            border: 1px solid #ffffff;
        }

        .disabled-btn {
            background-color: #666666 !important;
            cursor: not-allowed !important;
        }

        /* Styles for the new filename builder panel */
        .filename-builder-modal-content {
            background-color: #ffffff;
            margin: 5% auto;
            padding: 24px;
            border: none;
            border-radius: 8px;
            width: 90%;
            max-width: 720px; /* Wider for more complex builder */
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            animation: fadeIn 0.3s;
            color: #000000; /* Set default text color for the modal */
        }

        #filename-preview {
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-family: monospace;
            min-height: 24px;
            border: 1px solid #ddd;
            word-wrap: break-word;
            white-space: pre-wrap; /* Allow line breaks */
        }

        .filename-part-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .filename-part-row input[type="text"],
        .filename-part-row select {
            flex-grow: 1;
            margin-right: 8px;
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
            border-radius: 0;
            font-size: 14px;
            box-sizing: border-box;
        }

        .filename-part-row button {
            height: 36px;
            width: 36px;
            border: 1px solid #444444;
            background-color: #f2f2f2;
            color: #000000;
            cursor: pointer;
        }

        #add-filename-part-controls {
            display: flex;
            align-items: center;
            margin-top: 15px;
        }
        
        #add-filename-part-controls button {
            height: 36px;
            width: 36px;
            margin-right: 8px;
             border: 1px solid #444444;
            background-color: #1877f2;
            color: #ffffff;
            font-size: 20px;
            cursor: pointer;
        }

         #add-filename-part-controls select {
            height: 36px;
            padding: 0 8px;
            border: 1px solid #444444;
            background-color: #ffffff;
            color: #000000;
         }

        #create-filename-button-btn {
            background-color: #1877f2;
            color: #ffffff;
            border: 1px solid #444444;
            border-radius: 0;
            font-size: 14px;
            height: 36px;
            padding: 0 16px;
            cursor: pointer;
            display: block;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <div class="sidebar" id="sidebar">
            <div id="sidebar-resizer"></div>
            <div class="sidebar-buttons">
                <div class="dropdown">
                    <button class="sidebar-cog-btn" id="cog-btn">âš™</button>
                    <div class="dropdown-content" id="cog-dropdown">
                        <div id="project-username-container" style="padding: 12px 16px;">
                            <label for="project-username-input" style="display: block; margin-bottom: 5px;">Project Username</label>
                            <input type="text" id="project-username-input" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <a href="#" id="rename-canvas-btn">Rename Canvas</a>
                        <a href="#" id="scan-for-buttons-btn">Scan for Buttons</a>
                        <a href="#" id="remove-all-buttons-btn">Remove All Buttons</a>
                        <a href="#" id="generate-edit-btn">Generate Edit Thumbnails</a>
                        <div id="edit-mode-options" style="display:none;">
                            <a href="#" id="edit-mode-btn">Edit Mode: Off</a>
                            <a href="#" id="generate-edit-bat-btn">Generate Edit Bat</a>
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="num-elements-input" style="display: block; margin-bottom: 5px;">Number of Elements</label>
                            <input type="number" id="num-elements-input" min="1" value="1" style="width: 100%; box-sizing: border-box; background-color: #ffffff; border: 1px solid #444; color: black; padding: 4px;">
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                             <a href="#" id="visible-buttons-btn">Visible Buttons</a>
                        </div>
                        <div style="padding: 12px 16px; border-top: 1px solid #ddd;">
                            <label for="font-size-slider" style="display: block; margin-bottom: 5px;">Button Font Size</label>
                            <input type="range" id="font-size-slider" min="8" max="24" value="14" style="width: 100%;">
                        </div>
                        <div class="nested-dropdown" id="recent-directories-dropdown">
                            <a href="#">Recent Directories</a>
                            <div class="nested-dropdown-content" id="recent-directories-list">
                                <!-- Populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
                <button id="load-directory-btn">Load Directory</button>
            </div>
            <div id="sidebar-scroll-container">
                <!-- Custom buttons will be loaded here -->
            </div>
        </div>
        <div class="main-content">
            <div class="top-bar">
                <select id="size-selector">
                    <option value="0.2">20%</option>
                    <option value="0.3">30%</option>
                    <option value="0.4">40%</option>
                    <option value="0.5">50%</option>
                    <option value="0.6">60%</option>
                    <option value="0.7">70%</option>
                    <option value="0.8">80%</option>
                    <option value="0.9">90%</option>
                    <option value="1" selected>100%</option>
                </select>
                <select id="sort-selector">
                    <option value="" disabled hidden>Sort</option>
                    <option value="name">Name</option>
                    <option value="random">Random</option>
                </select>
                <input type="text" id="layout-name-input" placeholder="Layout Name">
                <button id="save-layout-btn">Save Layout</button>
                <select id="layout-select">
                    <option value="" disabled hidden>Layout Select</option>
                </select>
                <button id="load-layout-btn">Load Layout</button>
                <button id="delete-layout-btn">Delete Layout</button>
                <button id="multi-select-btn">Multi Select</button>
                <button id="deselect-all-btn">Deselect All</button>
                <button id="hide-btn" disabled>Hide</button>
                <button id="split-btn" disabled>Split</button>
                <select id="canvas-select">
                    <option value="1">Canvas 1</option>
                </select>
                <select id="send-to-canvas-select" disabled>
                    <option value="" disabled hidden>Send to...</option>
                </select>
                <button id="close-canvas-btn" disabled>Close Canvas</button>
                <button id="play-btn" disabled>Play</button>
            </div>
            <div id="thumbnail-container">
                <div id="selection-box"></div>
                <div id="content-spacer" style="position: absolute; top: 0; left: 0; z-index: -1;"></div>
            </div>
            <div class="bottom-bar">
                <div style="display: flex;">
                    <button id="new-filename-btn" style="height: 36px; padding: 0; width: 60px; text-align: center; border: 1px solid #444444; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">New</button>
                    <button id="remove-btn" style="height: 36px; padding: 0 12px; border: 1px solid #444444; border-left: none; background-color: #1877f2; color: #ffffff; border-radius: 0; font-size: 14px; box-sizing: border-box; cursor: pointer;">Remove</button>
                </div>
                <div id="bottom-bar-info" style="flex-grow: 1; text-align: right;"></div>
                <div id="landscape-buttons" style="display: none;">
                    <button id="deselect-row-btn">Deselect</button>
                    <button id="landscape-btn">Landscape</button>
                    <button id="landscape-rotate-btn">Landscape Rotate</button>
                    <button id="delete-btn">Delete</button>
                    <button id="edit-btn">Edit</button>
                </div>
            </div>
        </div>
    </div>

    <div id="filename-builder-modal" class="modal">
        <div class="filename-builder-modal-content">
            <span class="close">&times;</span>
            <h2>Create New Filename Button</h2>
            <p>Define a category and add one or more elements to create a button.</p>
            
            <h4>Preview:</h4>
            <div id="filename-preview"></div>

            <div id="filename-parts-container">
                <!-- Dynamic parts will be added here -->
            </div>

            <datalist id="previous-categories-list"></datalist>
            <datalist id="previous-elements-list"></datalist>

            <div id="add-filename-part-controls">
                <button id="add-element-btn">+</button>
            </div>

            <button id="create-filename-button-btn">Add Button</button>
        </div>
    </div>

    <div id="video-overlay" style="display: none;">
        <div id="video-player-container">
            <video id="video-player" controls></video>
            <button id="video-close-btn">X</button>
            <button id="video-prev-btn">&lt;&lt;</button>
            <button id="video-next-btn">&gt;&gt;</button>
        </div>
    </div>

    <div id="script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Thumbnails</h2>
            <p>The "Thumbnails" subdirectory is missing. Here is a batch script to generate them. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-script-btn">Copy to Clipboard</button>
            <a id="download-script-link" download="generate_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>
    
    <div id="visible-buttons-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Visible Buttons</h2>
            <p>Select which buttons to display in the sidebar.</p>
            <div id="visible-buttons-list-container" style="max-height: 400px; overflow-y: auto;">
                <!-- Button visibility controls will be dynamically added here -->
            </div>
        </div>
    </div>

    <div id="edit-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Generate Edit Thumbnails</h2>
            <p>This script will extract 10 screenshots from each video. You will need FFmpeg installed and in your system's PATH.</p>
            <textarea id="edit-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-edit-script-btn">Copy to Clipboard</button>
            <a id="download-edit-script-link" download="generate_edit_thumbnails.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-edit-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <div id="final-landscape-script-modal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Final Landscape/Rotate Batch Script</h2>
            <p>This script will process your selections. Run it in your main video directory.</p>
            <textarea id="final-landscape-batch-script" rows="10" cols="80" readonly></textarea>
            <button id="copy-final-landscape-script-btn">Copy to Clipboard</button>
            <a id="download-final-landscape-script-link" download="process_selections.bat">
                <button>Download .bat File</button>
            </a>
            <button id="reload-final-script-page-btn" style="display: none;">Reload Page</button>
        </div>
    </div>

    <script>
        // --- IndexedDB Helpers ---
        function getDb(key) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readonly');
                    const store = tx.objectStore('store');
                    const req = store.get(key);
                    req.onsuccess = () => resolve(req.result);
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }

        function setDb(key, value) {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('thumbnail-tool-db', 1);
                request.onupgradeneeded = () => request.result.createObjectStore('store');
                request.onsuccess = () => {
                    const tx = request.result.transaction('store', 'readwrite');
                    const store = tx.objectStore('store');
                    const req = store.put(value, key);
                    req.onsuccess = () => resolve();
                    req.onerror = () => reject(req.error);
                    tx.oncomplete = () => request.result.close();
                };
                request.onerror = () => reject(request.error);
            });
        }

        const directoryPicker = document.getElementById('directory-picker');
        const thumbnailContainer = document.getElementById('thumbnail-container');
        const scriptModal = document.getElementById('script-modal');
        const filenameBuilderModal = document.getElementById('filename-builder-modal');
        const batchScriptTextArea = document.getElementById('batch-script');
        const copyScriptBtn = document.getElementById('copy-script-btn');
        const downloadScriptLink = document.getElementById('download-script-link');
        const reloadPageBtn = document.getElementById('reload-page-btn');
        const closeModal = document.querySelector('.close');
        const sizeSelector = document.getElementById('size-selector');
        let isLayoutFrozen = false;
        var directoryName = '';
        let zIndexCounter = 1000;
        const loadButton = document.getElementById('load-directory-btn');
        const saveLayoutBtn = document.getElementById('save-layout-btn');
        const layoutNameInput = document.getElementById('layout-name-input');
        const layoutSelect = document.getElementById('layout-select');
        const loadLayoutBtn = document.getElementById('load-layout-btn');
        const deleteLayoutBtn = document.getElementById('delete-layout-btn');
        const selectionBox = document.getElementById('selection-box');
        const contentSpacer = document.getElementById('content-spacer');
        let selectedThumbnails = new Set();
        let allVideoFiles = [];
        const playBtn = document.getElementById('play-btn');
        let scanLayouts = {};
        const splitBtn = document.getElementById('split-btn');
        const canvasSelect = document.getElementById('canvas-select');
        const multiSelectBtn = document.getElementById('multi-select-btn');
        const sendToCanvasSelect = document.getElementById('send-to-canvas-select');
        const closeCanvasBtn = document.getElementById('close-canvas-btn');
        const renameCanvasBtn = document.getElementById('rename-canvas-btn');
        const scanForButtonsBtn = document.getElementById('scan-for-buttons-btn');
        const removeAllButtonsBtn = document.getElementById('remove-all-buttons-btn');
        const deselectAllBtn = document.getElementById('deselect-all-btn');
        const hideBtn = document.getElementById('hide-btn');
        let isMultiSelectMode = false;
        const sortSelector = document.getElementById('sort-selector');
        const cogBtn = document.getElementById('cog-btn');
        const newFilenameBtn = document.getElementById('new-filename-btn');
        const removeBtn = document.getElementById('remove-btn');
        const visibleButtonsBtn = document.getElementById('visible-buttons-btn');
        const visibleButtonsModal = document.getElementById('visible-buttons-modal');
        const visibleButtonsListContainer = document.getElementById('visible-buttons-list-container');
        const generateEditBtn = document.getElementById('generate-edit-btn');
        const editScriptModal = document.getElementById('edit-script-modal');
        const recentDirectoriesDropdown = document.getElementById('recent-directories-dropdown');
        
        let buttonsForRemoval = new Set();
        let filenameParts = [];
        const filenamePreview = document.getElementById('filename-preview');
        const filenamePartsContainer = document.getElementById('filename-parts-container');
        const addPartBtn = document.getElementById('add-part-btn');
        const createFilenameButtonBtn = document.getElementById('create-filename-button-btn');

        var canvases = new Map();
        let activeCanvasId = 1;
        let allThumbnails = [];
        let currentDirHandle;
        let landscapeSelectionMode = ''; // 'landscape' or 'landscape-rotate'
        const landscapeSelections = new Set();
        const landscapeRotateSelections = new Set();
        const deleteSelections = new Set();
        const editSelections = new Set();

        function updateRemoveButtonState() {
            if (buttonsForRemoval.size === 0) {
                removeBtn.classList.add('disabled-btn');
                removeBtn.disabled = true;
            } else {
                removeBtn.classList.remove('disabled-btn');
                removeBtn.disabled = false;
            }
        }

        function getNextCanvasId() {
            let i = 1;
            while (canvases.has(i)) {
                i++;
            }
            return i;
        }

        function renderCanvas(canvasId) {
            activeCanvasId = canvasId;
            thumbnailContainer.innerHTML = ''; // Clear container
            thumbnailContainer.appendChild(selectionBox);
            thumbnailContainer.appendChild(contentSpacer);

            const canvas = canvases.get(canvasId);
            if (canvas) {
                document.title = canvas.name;
                hideBtn.textContent = canvas.name === 'Hidden' ? 'Unhide' : 'Hide';
                canvas.thumbnails.forEach(thumb => {
                    thumbnailContainer.appendChild(thumb);
                });
            }

            const currentCanvas = canvases.get(activeCanvasId);
            closeCanvasBtn.disabled = !(currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1 && currentCanvas.name !== 'Renamed');
            
            populateCanvasDropdown();
            layoutThumbnailsInGrid();
        }

        function populateCanvasDropdown() {
            canvasSelect.innerHTML = '';
            sendToCanvasSelect.innerHTML = '<option value="" disabled selected hidden>Send to...</option>';
            for (const canvas of canvases.values()) {
                const option = document.createElement('option');
                option.value = canvas.id;
                option.textContent = canvas.name;
                canvasSelect.appendChild(option.cloneNode(true));
                if (canvas.id !== activeCanvasId) {
                    sendToCanvasSelect.appendChild(option);
                }
            }
            canvasSelect.value = activeCanvasId;
        }

        const videoOverlay = document.getElementById('video-overlay');
        const videoPlayer = document.getElementById('video-player');
        const videoCloseBtn = document.getElementById('video-close-btn');
        const videoPrevBtn = document.getElementById('video-prev-btn');
        const videoNextBtn = document.getElementById('video-next-btn');
        let playlist = [];
        let currentPlaylistIndex = -1;
        let currentVideoUrl = null;

        function loadVideo(index) {
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
            }
            
            currentPlaylistIndex = index;
            const thumb = playlist[index];
            const thumbName = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
            
            const videoFile = allVideoFiles.find(f => f.name.startsWith(thumbName));
            
            if (videoFile) {
                currentVideoUrl = URL.createObjectURL(videoFile);
                videoPlayer.src = currentVideoUrl;
                videoPlayer.play();
            }

            videoPrevBtn.style.display = index > 0 ? 'block' : 'none';
            videoNextBtn.style.display = index < playlist.length - 1 ? 'block' : 'none';
        }

        function updatePlayButtonState() {
            const numSelected = selectedThumbnails.size;
            playBtn.disabled = numSelected === 0;
            splitBtn.disabled = numSelected === 0;
            sendToCanvasSelect.disabled = numSelected === 0;
            hideBtn.disabled = numSelected === 0;

        }

        function updateContentSpacer() {
            const thumbnails = document.querySelectorAll('.thumbnail');
            if (thumbnails.length === 0) {
                contentSpacer.style.width = '0px';
                contentSpacer.style.height = '0px';
                return;
            }

            let maxRight = 0;
            let maxBottom = 0;

            thumbnails.forEach(thumb => {
                const right = thumb.offsetLeft + thumb.offsetWidth;
                const bottom = thumb.offsetTop + thumb.offsetHeight;
                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            // Add a small buffer
            contentSpacer.style.width = (maxRight + 20) + 'px';
            contentSpacer.style.height = (maxBottom + 20) + 'px';
        }

        async function init() {
            const savedSize = localStorage.getItem('thumbnailSize') || '1';
            sizeSelector.value = savedSize;
            await loadRecentDirectories();
            updateRemoveButtonState();

            recentDirectoriesDropdown.addEventListener('click', (event) => {
                event.stopPropagation();
                const list = document.getElementById('recent-directories-list');
                list.style.display = list.style.display === 'block' ? 'none' : 'block';
            });

            if (!directoryName) {
                directoryName = 'default'; // For testing purposes
            }

            const numElementsInput = document.getElementById('num-elements-input');
            numElementsInput.addEventListener('change', () => {
                localStorage.setItem(`${directoryName}-numElements`, numElementsInput.value);
                loadCustomButtons();
            });

            const fontSizeSlider = document.getElementById('font-size-slider');
            fontSizeSlider.addEventListener('input', () => {
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => {
                    button.style.fontSize = `${fontSizeSlider.value}px`;
                    adjustButtonFontSize(button);
                });
            });
            fontSizeSlider.addEventListener('change', () => {
                localStorage.setItem(`${directoryName}-fontSize`, fontSizeSlider.value);
            });

            const dirHandle = await getDb('lastDirectory');
            if (dirHandle && typeof dirHandle.queryPermission === 'function') {
                try {
                    const hasPermission = await dirHandle.queryPermission({ mode: 'read' }) === 'granted' ||
                                          await dirHandle.requestPermission({ mode: 'read' }) === 'granted';
                    if (hasPermission) {
                        await processDirectory(dirHandle);
                    } else {
                         console.error('Permission to access the last directory was denied.');
                         await setDb('lastDirectory', null);
                    }
                } catch (err) {
                    console.error('Could not auto-load directory:', err);
                    await setDb('lastDirectory', null);
                    await loadRecentDirectories(); 
                }
            } else if (dirHandle) {
                console.warn('Last directory handle from IndexedDB was invalid. Clearing.');
                await setDb('lastDirectory', null);
            }
        }

        loadButton.addEventListener('click', async () => {
            try {
                const dirHandle = await window.showDirectoryPicker();
                await processDirectory(dirHandle);
            } catch (err) {
                if (err.name !== 'AbortError') console.error('Failed to open directory:', err);
            }
        });

        cogBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            const dropdown = document.getElementById('cog-dropdown');
            dropdown.style.display = dropdown.style.display === 'block' ? 'none' : 'block';
        });

        // Prevent clicks inside the dropdown from closing it
        document.getElementById('cog-dropdown').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        generateEditBtn.addEventListener('click', () => {
            if (allVideoFiles.length === 0) {
                alert('No video files loaded. Please load a directory first.');
                return;
            }
            generateEditBatchScript(allVideoFiles);
            editScriptModal.style.display = 'block';
        });

        editScriptModal.querySelector('.close').addEventListener('click', () => {
            editScriptModal.style.display = 'none';
        });

        document.getElementById('copy-edit-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('edit-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-edit-script-link').addEventListener('click', () => {
            document.getElementById('reload-edit-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-edit-page-btn').addEventListener('click', () => {
            location.reload();
        });

        document.getElementById('landscape-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape' ? '' : 'landscape';
            updateSelectionModeButtons();
        });

        document.getElementById('landscape-rotate-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'landscape-rotate' ? '' : 'landscape-rotate';
            updateSelectionModeButtons();
        });

        document.getElementById('delete-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'delete' ? '' : 'delete';
            updateSelectionModeButtons();
        });

        document.getElementById('edit-btn').addEventListener('click', () => {
            landscapeSelectionMode = landscapeSelectionMode === 'edit' ? '' : 'edit';
            updateSelectionModeButtons();
        });

        document.getElementById('deselect-row-btn').addEventListener('click', () => {
            landscapeSelections.clear();
            landscapeRotateSelections.clear();
            deleteSelections.clear();
            editSelections.clear();

            document.querySelectorAll('.landscape-row').forEach(row => {
                row.classList.remove('selected-landscape', 'selected-landscape-rotate', 'selected-delete', 'selected-edit');
            });
        });

        function updateSelectionModeButtons() {
            const blue = '#1877f2';
            const red = '#d93025';
            document.getElementById('landscape-btn').style.backgroundColor = landscapeSelectionMode === 'landscape' ? red : blue;
            document.getElementById('landscape-rotate-btn').style.backgroundColor = landscapeSelectionMode === 'landscape-rotate' ? red : blue;
            document.getElementById('delete-btn').style.backgroundColor = landscapeSelectionMode === 'delete' ? red : blue;
            document.getElementById('edit-btn').style.backgroundColor = landscapeSelectionMode === 'edit' ? red : blue;
        }


        const projectUsernameInput = document.getElementById('project-username-input');
        projectUsernameInput.addEventListener('change', () => {
            if (directoryName) {
                localStorage.setItem(`${directoryName}-projectUsername`, projectUsernameInput.value);
            }
            updateFilenamePreview();
        });

        document.getElementById('project-username-container').addEventListener('click', (event) => {
            event.stopPropagation();
        });

        window.addEventListener('click', (event) => {
            const dropdown = document.getElementById('cog-dropdown');
            // If the click is outside the cog button AND outside the dropdown content
            if (!event.target.matches('.sidebar-cog-btn') && !dropdown.contains(event.target)) {
                if (dropdown.style.display === 'block') {
                    dropdown.style.display = 'none';
                    document.getElementById('recent-directories-list').style.display = 'none';
                }
            }
        });

        renameCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                if (currentCanvas.name === 'Renamed') {
                    alert('The "Renamed" canvas cannot be renamed.');
                    return;
                }
                const newName = prompt('Enter new name for the canvas:', currentCanvas.name);
                if (newName && newName.trim() !== '') {
                    currentCanvas.name = newName.trim();
                    document.title = newName.trim();
                    populateCanvasDropdown();
                }
            }
            document.getElementById('cog-dropdown').style.display = 'none';
        });

        removeAllButtonsBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to remove all custom buttons for this directory?')) {
                localStorage.setItem(`${directoryName}-customButtons`, '[]');
                loadCustomButtons(); // This will clear the sidebar
                alert('All custom buttons have been removed.');
            }
            document.getElementById('cog-dropdown').style.display = 'none';
        });

        function insertButtonIntoTree(tree, path, buttonData) {
            let currentLevel = tree;
            let node = null;

            for (let i = 0; i < path.length; i++) {
                const name = path[i];
                const isButton = i === path.length - 1;

                node = currentLevel.find(item => item.name === name && item.type === (isButton ? 'button' : 'category'));

                if (!node) {
                    node = {
                        name: name,
                        type: isButton ? 'button' : 'category',
                    };
                    if (isButton) {
                        Object.assign(node, { id: buttonData.id || Date.now() + Math.random(), ...buttonData });
                    } else {
                        node.children = [];
                    }
                    currentLevel.push(node);
                } else if (isButton) {
                    // If a button with the same path already exists, it's a duplicate.
                    return false; 
                }
                
                if (!isButton) {
                    currentLevel = node.children;
                }
            }
            return true; // Indicates a new button was successfully added
        }

        scanForButtonsBtn.addEventListener('click', async () => {
            let username = projectUsernameInput.value.trim();
            if (!username) {
                username = prompt('Please enter a Project Username to scan for matching filenames:');
                if (username) {
                    projectUsernameInput.value = username;
                    projectUsernameInput.dispatchEvent(new Event('change'));
                } else {
                    alert('Scan cancelled. A Project Username is required.');
                    return;
                }
            }

            let customButtonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');
            let newButtonsCreated = 0;

            // Regex explained:
            // ^\\[${username}\\]_  - Matches "[username]_" at the start of the string.
            // ([^(]+)             - Captures the Category. Matches any character except '('. This is more flexible than \w+.
            // (.*)                 - Captures the rest of the string, which contains the elements.
            const regex = new RegExp(`^\\[${username}\\]_([^(]+)(.*)`);

            for (const file of allVideoFiles) {
                const match = file.name.match(regex);
                if (!match) continue;

                const category = match[1].trim();
                let rawElementsText = match[2] || '';
                
                // Clean up raw elements string: remove file extension and trailing number like (1)
                rawElementsText = rawElementsText.substring(0, rawElementsText.lastIndexOf('.')).trim();
                rawElementsText = rawElementsText.replace(/\s*\(\d+\)$/, '').trim();

                // Extract all parenthesized elements, e.g., "(Coat)" "(Black 1)"
                const elementsWithParens = rawElementsText.match(/\(([^)]+)\)/g) || [];
                
                if (elementsWithParens.length === 0) {
                    // This handles filenames like "[user]_Misc.mp4" or "[user]_Misc (1).mp4"
                    // A special "+1" button is created for simple renaming.
                    const path = [category, '+1'];
                    const buttonData = {
                        fullButtonText: '',
                        specialType: 'plusOne'
                    };
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                } else {
                    // This handles hierarchical names like "[user]_Misc (Coat) (Black 1).mp4"
                    // 1. Remove parentheses to get clean element names: ["Coat", "Black 1"]
                    const cleanElements = elementsWithParens.map(p => p.slice(1, -1));
                    
                    // 2. The full path for the tree structure: ["Misc", "Coat", "Black 1"]
                    const path = [category, ...cleanElements];
                    
                    // 3. Store the original text with parentheses for other features like highlighting
                    const buttonData = {
                        fullButtonText: elementsWithParens.join(' ')
                    };
                    
                    // 4. Insert into the tree, checking for duplicates.
                    if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                        newButtonsCreated++;
                    }
                }
            }

            if (newButtonsCreated > 0) {
                localStorage.setItem(`${directoryName}-customButtons`, JSON.stringify(customButtonTree));
                await loadCustomButtons();
                alert(`${newButtonsCreated} new button(s) created successfully!`);
            } else {
                alert('No new buttons were found. They may already exist or not match the current Project Username.');
            }
            
            document.getElementById('cog-dropdown').style.display = 'none';
        });


        sortSelector.addEventListener('change', (e) => {
            const value = e.target.value;
            if (value) {
                sortThumbnails(value);
                e.target.value = ''; // Reset to placeholder
            }
        });

        saveLayoutBtn.addEventListener('click', saveLayout);
        loadLayoutBtn.addEventListener('click', loadLayout);
        multiSelectBtn.addEventListener('click', () => {
            isMultiSelectMode = !isMultiSelectMode;
            multiSelectBtn.classList.toggle('active', isMultiSelectMode);
        });

        deselectAllBtn.addEventListener('click', () => {
            selectedThumbnails.forEach(thumb => thumb.classList.remove('selected'));
            selectedThumbnails.clear();
            updatePlayButtonState();
        });

        hideBtn.addEventListener('click', () => {
            if (hideBtn.textContent === 'Hide') {
                let hiddenCanvas = Array.from(canvases.values()).find(c => c.name === 'Hidden');
                if (!hiddenCanvas) {
                    const newCanvasId = getNextCanvasId();
                    hiddenCanvas = { id: newCanvasId, name: 'Hidden', thumbnails: [] };
                    canvases.set(newCanvasId, hiddenCanvas);
                }

                selectedThumbnails.forEach(thumb => {
                    thumb.dataset.previousCanvasId = activeCanvasId;
                });
                
                sendThumbnailsToCanvas(hiddenCanvas.id);
            } else { // Unhide
                const thumbnailsToUnhide = new Map();
                selectedThumbnails.forEach(thumb => {
                    const targetCanvasId = parseInt(thumb.dataset.previousCanvasId) || 1; // Default to canvas 1 if unset
                    if (!thumbnailsToUnhide.has(targetCanvasId)) {
                        thumbnailsToUnhide.set(targetCanvasId, []);
                    }
                    thumbnailsToUnhide.get(targetCanvasId).push(thumb);
                });

                const currentCanvas = canvases.get(activeCanvasId);
                thumbnailsToUnhide.forEach((thumbs, targetId) => {
                    const targetCanvas = canvases.get(targetId);
                    if (targetCanvas) {
                        thumbs.forEach(thumb => {
                            currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                            targetCanvas.thumbnails.push(thumb);
                            thumb.classList.remove('selected');
                        });
                    }
                });

                selectedThumbnails.clear();
                renderCanvas(activeCanvasId);
                updatePlayButtonState();
            }
        });

        deleteLayoutBtn.addEventListener('click', deleteLayout);
        splitBtn.addEventListener('click', () => {
            const newCanvasId = getNextCanvasId();
            const newCanvas = { id: newCanvasId, name: `Canvas ${newCanvasId}`, thumbnails: [] };
            canvases.set(newCanvasId, newCanvas);

            const currentCanvas = canvases.get(activeCanvasId);
            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                newCanvas.thumbnails.push(thumb); // Positions are preserved
                thumb.classList.remove('selected');
            });

            selectedThumbnails.clear();
            updatePlayButtonState();
            
            populateCanvasDropdown();
            canvasSelect.value = newCanvasId;
            renderCanvas(newCanvasId);
        });
        canvasSelect.addEventListener('change', (e) => {
            renderCanvas(parseInt(e.target.value));
        });

        sendToCanvasSelect.addEventListener('change', (e) => {
            const targetCanvasId = parseInt(e.target.value);
            if (!targetCanvasId) return;
            sendThumbnailsToCanvas(targetCanvasId);
            e.target.value = ''; // Reset dropdown
        });

        closeCanvasBtn.addEventListener('click', () => {
            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas && currentCanvas.thumbnails.length === 0 && canvases.size > 1) {
                canvases.delete(activeCanvasId);
                const newActiveCanvasId = canvases.keys().next().value;
                populateCanvasDropdown();
                canvasSelect.value = newActiveCanvasId;
                renderCanvas(newActiveCanvasId);
            }
        });

        function sendThumbnailsToCanvas(targetCanvasId, clearSelection = true) {
            const targetCanvas = canvases.get(targetCanvasId);
            if (!targetCanvas) return;

            const currentCanvas = canvases.get(activeCanvasId);

            selectedThumbnails.forEach(thumb => {
                currentCanvas.thumbnails = currentCanvas.thumbnails.filter(t => t !== thumb);
                targetCanvas.thumbnails.push(thumb);
                if(clearSelection) {
                    thumb.classList.remove('selected');
                }
            });

            if (clearSelection) {
                selectedThumbnails.clear();
            }
            renderCanvas(activeCanvasId); // Re-render the current canvas to show the items have moved
            updatePlayButtonState();
        }

        playBtn.addEventListener('click', () => {
            playlist = Array.from(selectedThumbnails);
            if (playlist.length > 0) {
                videoOverlay.style.display = 'flex';
                loadVideo(0);
            }
        });
        videoCloseBtn.addEventListener('click', () => {
            videoOverlay.style.display = 'none';
            videoPlayer.pause();
            if (currentVideoUrl) {
                URL.revokeObjectURL(currentVideoUrl);
                currentVideoUrl = null;
            }
        });
        videoPrevBtn.addEventListener('click', () => {
            if (currentPlaylistIndex > 0) {
                loadVideo(currentPlaylistIndex - 1);
            }
        });
        videoNextBtn.addEventListener('click', () => {
            if (currentPlaylistIndex < playlist.length - 1) {
                loadVideo(currentPlaylistIndex + 1);
            }
        });

        thumbnailContainer.addEventListener('mousedown', startSelection);

        closeModal.addEventListener('click', () => scriptModal.style.display = 'none');
        copyScriptBtn.addEventListener('click', copyScriptToClipboard);
        downloadScriptLink.addEventListener('click', downloadBatchFile);
        sizeSelector.addEventListener('change', (event) => {
            const newSize = event.target.value;
            localStorage.setItem('thumbnailSize', newSize);
            const editModeBtn = document.getElementById('edit-mode-btn');
            if (editModeBtn && editModeBtn.textContent.includes('On')) {
                layoutLandscapeThumbnails();
            } else {
                layoutThumbnailsInGrid();
            }
        });

        function layoutThumbnailsInGrid() {
            if (isLayoutFrozen) {
                const scale = parseFloat(sizeSelector.value);
                thumbnailContainer.querySelectorAll('.thumbnail-wrapper').forEach(wrapper => {
                    const thumb = wrapper.querySelector('.thumbnail');
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const originalWidth = thumb.dataset.originalWidth;
                    if (originalWidth) {
                        const scaledWidth = originalWidth * scale;
                        thumb.style.width = scaledWidth + 'px';
                        thumb.style.height = 'auto';
                        nameDiv.style.maxWidth = scaledWidth + 'px';
                    }
                });
                updateContentSpacer();
                return;
            }

            const scale = parseFloat(sizeSelector.value);
            const containerWidth = thumbnailContainer.clientWidth;
            let xOffset = 20;
            let yOffset = 20;
            let maxRowHeight = 0;

            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');

            wrappers.forEach(wrapper => {
                const thumb = wrapper.querySelector('.thumbnail');
                const nameDiv = wrapper.querySelector('.thumbnail-name');
                
                // Temporarily make the name visible to get its height for layout calculation
                const originalDisplay = nameDiv.style.display;
                nameDiv.style.display = 'block';

                const originalWidth = parseFloat(thumb.dataset.originalWidth);
                const originalHeight = parseFloat(thumb.dataset.originalHeight);
                
                const scaledWidth = originalWidth * scale;
                const scaledHeight = originalHeight * scale;

                nameDiv.style.maxWidth = scaledWidth + 'px';
                const nameHeight = nameDiv.offsetHeight;
                
                // Restore the original display property
                nameDiv.style.display = originalDisplay;

                const wrapperHeight = scaledHeight + nameHeight + 4;

                if (xOffset + scaledWidth + 20 > containerWidth && xOffset > 20) {
                    xOffset = 20;
                    yOffset += maxRowHeight + 20;
                    maxRowHeight = 0;
                }
                
                wrapper.style.position = 'absolute';
                wrapper.style.left = xOffset + 'px';
                wrapper.style.top = yOffset + 'px';
                thumb.style.width = scaledWidth + 'px';
                thumb.style.height = scaledHeight + 'px';

                if (wrapperHeight > maxRowHeight) {
                    maxRowHeight = wrapperHeight;
                }
                
                xOffset += scaledWidth + 20;
            });

            updateContentSpacer();
        }

        async function processDirectory(dirHandle) {
            // --- Clear previous state ---
            thumbnailContainer.innerHTML = ''; // Clear thumbnails
            document.getElementById('sidebar-scroll-container').innerHTML = ''; // Clear buttons
            canvases.clear();
            allThumbnails = [];
            isLayoutFrozen = false;
            document.getElementById('edit-mode-options').style.display = 'none';


            currentDirHandle = dirHandle;
            await setDb('lastDirectory', dirHandle);
            
            let recentDirs = await getDb('recentDirectories') || [];
            const existingIndex = recentDirs.findIndex(dir => dir.name === dirHandle.name);
            if (existingIndex > -1) {
                recentDirs.splice(existingIndex, 1);
            }
            recentDirs.unshift({name: dirHandle.name, handle: dirHandle});
            if (recentDirs.length > 5) {
                recentDirs = recentDirs.slice(0, 5);
            }
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();

            directoryName = dirHandle.name;
            document.title = directoryName; // Update page title
            projectUsernameInput.value = localStorage.getItem(`${directoryName}-projectUsername`) || '';

            const savedNumElements = localStorage.getItem(`${directoryName}-numElements`);
            document.getElementById('num-elements-input').value = savedNumElements || 1;
            
            const savedFontSize = localStorage.getItem(`${directoryName}-fontSize`);
            document.getElementById('font-size-slider').value = savedFontSize || 14;

            loadCustomButtons();

            try {
                let hasEditThumbnails = false;
            let hasLandscapeVideos = false;
            let hasLandscapeRotateVideos = false;
            let hasEditVideos = false;

            try {
                await dirHandle.getDirectoryHandle('Edit Thumbnails');
                hasEditThumbnails = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }

            try {
                await dirHandle.getDirectoryHandle('Landscape');
                hasLandscapeVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Landscape Rotate');
                hasLandscapeRotateVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }
            
            try {
                await dirHandle.getDirectoryHandle('Edit');
                hasEditVideos = true;
            } catch (e) { /* Folder doesn't exist, which is fine. */ }


            if (hasEditThumbnails) {
                const editModeOptions = document.getElementById('edit-mode-options');
                const editModeBtn = document.getElementById('edit-mode-btn');
                const generateBatBtn = document.getElementById('generate-edit-bat-btn');

                editModeOptions.style.display = 'block';
                
                // Reset state for the new directory
                editModeBtn.textContent = 'Edit Mode Off';
                generateBatBtn.style.display = 'none';
                document.getElementById('landscape-buttons').style.display = 'none';
                
                // --- Attach listeners only once ---
                if (!editModeBtn.dataset.listenerAttached) {
                    editModeBtn.dataset.listenerAttached = 'true';
                    generateBatBtn.dataset.listenerAttached = 'true';

                    editModeBtn.addEventListener('click', () => {
                        if (editModeBtn.textContent.includes('Off')) {
                            renderEditMode();
                            generateBatBtn.style.display = 'block';
                            editModeBtn.textContent = 'Edit Mode On';
                        } else {
                            document.getElementById('landscape-buttons').style.display = 'none';
                            generateBatBtn.style.display = 'none';
                            editModeBtn.textContent = 'Edit Mode Off';
                            renderCanvas(activeCanvasId);
                        }
                    });

                    generateBatBtn.addEventListener('click', () => {
                        generateFinalBatchScript();
                        document.getElementById('final-landscape-script-modal').style.display = 'block';
                    });
                }
            }

            isLayoutFrozen = false;
            selectedThumbnails.clear();
            updatePlayButtonState();
            
            allVideoFiles = [];
            let thumbnailFiles = [];
            let hasThumbnailsSubdir = false;

            async function recursivelyFindThumbnails(dirHandle, pathPrefix = '') {
                const thumbnailsDirHandle = await dirHandle.getDirectoryHandle('Thumbnails');
                for await (const entry of thumbnailsDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                        thumbnailFiles.push(await entry.getFile());
                    }
                }
            }

            scanLayouts = {}; // Reset scan layouts
            try {
                const scanDirHandle = await dirHandle.getDirectoryHandle('scan');
                for await (const entry of scanDirHandle.values()) {
                    if (entry.kind === 'file' && entry.name.endsWith('.json')) {
                        const file = await entry.getFile();
                        const text = await file.text();
                        try {
                            const layoutName = entry.name.replace('.json', '');
                            scanLayouts[layoutName] = JSON.parse(text);
                        } catch (e) {
                            console.error(`Error parsing ${entry.name}:`, e);
                        }
                    }
                }
            } catch (e) {
                // scan directory doesn't exist, which is fine.
            }

            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(mp4|avi|mov|mkv)$/i)) {
                    allVideoFiles.push(await entry.getFile());
                }
            }

            try {
                // Find thumbnails in the root and other key directories
                await recursivelyFindThumbnails(dirHandle);
                hasThumbnailsSubdir = true;

                for (const subDir of ['Landscape', 'Landscape Rotate', 'Edit']) {
                    try {
                        const subDirHandle = await dirHandle.getDirectoryHandle(subDir);
                        await recursivelyFindThumbnails(subDirHandle, subDir);
                    } catch (e) {
                        // Subdirectory doesn't exist, which is fine.
                    }
                }
            } catch (e) {
                hasThumbnailsSubdir = false;
            }
            
            if (hasThumbnailsSubdir) {
                const savedCanvasData = JSON.parse(localStorage.getItem(`${directoryName}-canvasData`));

                allThumbnails = [];
                canvases.clear();
                
                const imageLoadPromises = thumbnailFiles.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.classList.add('thumbnail');
                        img.draggable = false;
                        img.dataset.fileName = file.name;
                        img.src = URL.createObjectURL(file);
                    });
                });

                Promise.all(imageLoadPromises).then(async loadedImages => {
                    allThumbnails = loadedImages;
                    
                    try {
                        if (!savedCanvasData || !Array.isArray(savedCanvasData.canvases)) throw new Error("No valid saved data");

                        canvases = new Map(savedCanvasData.canvases.map(c => [c.id, { ...c, thumbnails: [] }]));
                        activeCanvasId = savedCanvasData.activeCanvasId;

                        const thumbMap = new Map(allThumbnails.map(t => [t.dataset.fileName, t]));

                        savedCanvasData.canvases.forEach(savedCanvas => {
                            const canvas = canvases.get(savedCanvas.id);
                             if (!canvas) return; // Skip if a canvas from save data doesn't exist
                            savedCanvas.thumbnails.forEach(savedThumb => {
                                const thumb = thumbMap.get(savedThumb.fileName);
                                if (thumb) {
                                    canvas.thumbnails.push(thumb);
                                    thumb.style.position = 'absolute';
                                    thumb.style.left = savedThumb.left;
                                    thumb.style.top = savedThumb.top;
                                     if (savedThumb.previousCanvasId) {
                                        thumb.dataset.previousCanvasId = savedThumb.previousCanvasId;
                                     }
                                    isLayoutFrozen = true;
                                }
                            });
                        });
                         // Verify that the active canvas actually exists, otherwise reset it.
                        if (!canvases.has(activeCanvasId)) {
                            activeCanvasId = canvases.keys().next().value || 1;
                        }

                    } catch (err) {
                        console.warn("Could not restore canvas from saved data. Deleting invalid data and loading fresh.", err);
                        localStorage.removeItem(`${directoryName}-canvasData`); // Self-heal by deleting bad data
                        canvases.clear();
                        canvases.set(1, { id: 1, name: 'Canvas 1', thumbnails: [...allThumbnails] });
                        activeCanvasId = 1;
                        isLayoutFrozen = false;
                    }

                    let renamedCanvas = Array.from(canvases.values()).find(c => c.name === 'Renamed');
                    if (!renamedCanvas) {
                        const renamedCanvasId = getNextCanvasId();
                        canvases.set(renamedCanvasId, { id: renamedCanvasId, name: 'Renamed', thumbnails: [] });
                    }

                    // --- Auto-organize processed thumbnails ---
                    if (hasLandscapeVideos || hasLandscapeRotateVideos) {
                        const organizeProcessedThumbnails = async () => {
                            const getOrCreateCanvas = (name) => {
                                let canvas = Array.from(canvases.values()).find(c => c.name === name);
                                if (!canvas) {
                                    const newId = getNextCanvasId();
                                    canvas = { id: newId, name: name, thumbnails: [] };
                                    canvases.set(newId, canvas);
                                }
                                return canvas;
                            };

                            const moveThumbnailsToCanvas = async (dirName, targetCanvas) => {
                                try {
                                    const dirHandle = await currentDirHandle.getDirectoryHandle(dirName);
                                    const processedFiles = new Set();
                                    for await (const entry of dirHandle.values()) {
                                        if (entry.kind === 'file') {
                                            processedFiles.add(entry.name.substring(0, entry.name.lastIndexOf('.')));
                                        }
                                    }

                                    for (const sourceCanvas of canvases.values()) {
                                        if (sourceCanvas.id === targetCanvas.id) continue;

                                        const thumbnailsToMove = [];
                                        sourceCanvas.thumbnails = sourceCanvas.thumbnails.filter(thumb => {
                                            const baseName = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                                            if (processedFiles.has(baseName)) {
                                                if (!targetCanvas.thumbnails.some(t => t.dataset.fileName === thumb.dataset.fileName)) {
                                                    thumbnailsToMove.push(thumb);
                                                }
                                                return false; // Remove from source
                                            }
                                            return true; // Keep in source
                                        });

                                        if (thumbnailsToMove.length > 0) {
                                            targetCanvas.thumbnails.push(...thumbnailsToMove);
                                        }
                                    }
                                } catch (e) {
                                    console.warn(`Could not process directory ${dirName}:`, e);
                                }
                            };

                            if (hasLandscapeVideos) {
                                const landscapeCanvas = getOrCreateCanvas('Landscape');
                                await moveThumbnailsToCanvas('Landscape', landscapeCanvas);
                            }

                            if (hasLandscapeRotateVideos) {
                                const landscapeRotateCanvas = getOrCreateCanvas('Landscape Rotate');
                                await moveThumbnailsToCanvas('Landscape Rotate', landscapeRotateCanvas);
                            }
                            
                            if (hasEditVideos) {
                                const editCanvas = getOrCreateCanvas('Edit');
                                await moveThumbnailsToCanvas('Edit', editCanvas);
                            }
                        };

                        await organizeProcessedThumbnails();
                    }

                    allThumbnails.forEach(img => {
                        // Create a wrapper for the image and its name
                        const wrapper = document.createElement('div');
                        wrapper.classList.add('thumbnail-wrapper');
                        wrapper.appendChild(img);

                        const nameDiv = document.createElement('div');
                        nameDiv.classList.add('thumbnail-name');
                        nameDiv.textContent = img.dataset.fileName;
                        nameDiv.dataset.originalFilename = img.dataset.fileName;
                        wrapper.appendChild(nameDiv);

                        // Replace the img with the wrapper in the canvases map
                        for (const canvas of canvases.values()) {
                            const index = canvas.thumbnails.indexOf(img);
                            if (index > -1) {
                                canvas.thumbnails[index] = wrapper;
                                break;
                            }
                        }

                        makeDraggable(wrapper);
                        
                        nameDiv.addEventListener('dblclick', () => {
                            nameDiv.contentEditable = true;
                            nameDiv.focus();
                        });

                        nameDiv.addEventListener('blur', () => {
                            nameDiv.contentEditable = false;
                            // Update the image's data attribute with the new name
                            img.dataset.fileName = nameDiv.textContent;
                        });


                    });
                    
                    populateCanvasDropdown();
                    renderCanvas(activeCanvasId);
                });

            } else if (allVideoFiles.length > 0) {
                generateBatchScript(allVideoFiles, directoryName);
                scriptModal.style.display = 'block';
            }
            } catch (err) {
                console.error("A critical error occurred while processing the directory:", err);
                alert("An unexpected error occurred while trying to read the directory contents. Please try loading the directory again.");
            } finally {
                populateLayoutsDropdown();
            }
        }

        async function loadRecentDirectories() {
            const recentDirs = await getDb('recentDirectories') || [];
            const list = document.getElementById('recent-directories-list');
            list.innerHTML = '';

            if (recentDirs.length > 0) {
                for (const dir of recentDirs) {
                    const a = document.createElement('a');
                    a.href = '#';
                    a.textContent = dir.name;
                    a.title = dir.name;
                    a.addEventListener('click', async (e) => {
                        e.preventDefault();
                        // --- Validate handle before use ---
                        if (!dir.handle || typeof dir.handle.queryPermission !== 'function') {
                            alert('This directory reference is stale. Please re-select it using "Load Directory".');
                            await removeDirectory(dir.name);
                            return;
                        }

                        try {
                            const hasPermission = await dir.handle.queryPermission({ mode: 'read' }) === 'granted' ||
                                                  await dir.handle.requestPermission({ mode: 'read' }) === 'granted';
                            if (hasPermission) {
                                await processDirectory(dir.handle);
                                document.getElementById('cog-dropdown').style.display = 'none'; // Close menu after loading
                            }
                        } catch(e) {
                            alert('Could not access directory. It may have been moved, deleted, or permissions were denied.');
                            await removeDirectory(dir.name);
                        }
                    });
                    list.appendChild(a);
                }
            } else {
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = 'No recent directories';
                a.style.pointerEvents = 'none';
                list.appendChild(a);
            }
        }

        async function removeDirectory(dirName) {
            let recentDirs = await getDb('recentDirectories') || [];
            recentDirs = recentDirs.filter(d => d.name !== dirName);
            await setDb('recentDirectories', recentDirs);
            await loadRecentDirectories();
        }

        async function renderEditMode() {
            thumbnailContainer.innerHTML = ''; // Clear container for a clean slate
            document.getElementById('landscape-buttons').style.display = 'flex'; // Ensure buttons are visible

            const editDirHandle = await currentDirHandle.getDirectoryHandle('Edit Thumbnails');
            let landscapeFiles = [];
            for await (const entry of editDirHandle.values()) {
                if (entry.kind === 'file' && entry.name.match(/\.(jpe?g|png|gif|webp)$/i)) {
                    landscapeFiles.push(await entry.getFile());
                }
            }

            const groupedFiles = landscapeFiles.reduce((acc, file) => {
                const videoName = file.name.substring(0, file.name.lastIndexOf('_'));
                if (!acc[videoName]) {
                    acc[videoName] = [];
                }
                acc[videoName].push(file);
                return acc;
            }, {});

            const videoNames = Object.keys(groupedFiles).sort();
            const allPromises = [];

            for (const videoName of videoNames) {
                const files = groupedFiles[videoName];
                files.sort((a, b) => {
                    const aNum = parseInt(a.name.substring(a.name.lastIndexOf('_') + 1));
                    const bNum = parseInt(b.name.substring(b.name.lastIndexOf('_') + 1));
                    return aNum - bNum;
                });

                const rowDiv = document.createElement('div');
                rowDiv.classList.add('landscape-row');
                rowDiv.dataset.videoName = videoName;
                thumbnailContainer.appendChild(rowDiv);

                rowDiv.addEventListener('click', () => {
                    const selections = {
                        'landscape': landscapeSelections,
                        'landscape-rotate': landscapeRotateSelections,
                        'delete': deleteSelections,
                        'edit': editSelections
                    };

                    if (!landscapeSelectionMode) {
                        alert('Please select a mode from the bottom bar first.');
                        return;
                    }

                    // Toggle selection for the current mode
                    if (selections[landscapeSelectionMode].has(videoName)) {
                        selections[landscapeSelectionMode].delete(videoName);
                    } else {
                        selections[landscapeSelectionMode].add(videoName);
                        // Ensure mutual exclusivity
                        for (const mode in selections) {
                            if (mode !== landscapeSelectionMode) {
                                selections[mode].delete(videoName);
                            }
                        }
                    }

                    // Update UI classes
                    rowDiv.classList.toggle('selected-landscape', landscapeSelections.has(videoName));
                    rowDiv.classList.toggle('selected-landscape-rotate', landscapeRotateSelections.has(videoName));
                    rowDiv.classList.toggle('selected-delete', deleteSelections.has(videoName));
                    rowDiv.classList.toggle('selected-edit', editSelections.has(videoName));
                });

                 // Re-apply selection classes on initial render
                if (landscapeSelections.has(videoName)) rowDiv.classList.add('selected-landscape');
                if (landscapeRotateSelections.has(videoName)) rowDiv.classList.add('selected-landscape-rotate');
                if (deleteSelections.has(videoName)) rowDiv.classList.add('selected-delete');
                if (editSelections.has(videoName)) rowDiv.classList.add('selected-edit');

                const imageLoadPromises = files.map(file => {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            img.classList.add('thumbnail');
                            img.dataset.fileName = file.name;
                            img.dataset.originalWidth = img.width;
                            img.dataset.originalHeight = img.height;
                            rowDiv.appendChild(img);
                            resolve(img);
                        };
                        img.onerror = reject;
                        img.src = URL.createObjectURL(file);
                    });
                });
                allPromises.push(Promise.all(imageLoadPromises));
            }

            await Promise.all(allPromises);
            layoutLandscapeThumbnails(); // Position and size after all images are loaded
        }

        function layoutLandscapeThumbnails() {
            const scale = parseFloat(sizeSelector.value);
            let yOffset = 20;
            const rows = document.querySelectorAll('.landscape-row');

            rows.forEach(row => {
                row.style.position = 'absolute';
                row.style.top = yOffset + 'px';
                let xOffset = 20;
                let maxRowHeight = 0;
                let totalRowWidth = 0;
                const thumbnails = row.querySelectorAll('.thumbnail');
                
                thumbnails.forEach((thumb, index) => {
                    const originalWidth = parseFloat(thumb.dataset.originalWidth);
                    const originalHeight = parseFloat(thumb.dataset.originalHeight);
                    
                    const scaledWidth = originalWidth * scale;
                    const scaledHeight = originalHeight * scale;

                    thumb.style.position = 'absolute';
                    thumb.style.width = scaledWidth + 'px';
                    thumb.style.height = scaledHeight + 'px';
                    thumb.style.left = xOffset + 'px';
                    thumb.style.top = '0px'; // Position relative to the row

                    xOffset += scaledWidth + 20;
                    if (scaledHeight > maxRowHeight) {
                        maxRowHeight = scaledHeight;
                    }
                });

                if (thumbnails.length > 0) {
                    totalRowWidth = xOffset;
                    row.style.width = totalRowWidth + 'px';
                    row.style.height = maxRowHeight + 'px';
                    yOffset += maxRowHeight + 20;
                }
            });
             updateContentSpacer();
        }

        function generateEditBatchScript(videoFiles) {
            const scriptLines = [
                '@echo off',
                'setlocal enabledelayedexpansion',
                'cd /d "%~dp0"',
                'echo Creating Edit Thumbnails directory...',
                'if not exist "Edit Thumbnails" mkdir "Edit Thumbnails"',
                'echo Generating edit thumbnails...',
                ...videoFiles.flatMap(file => {
                    const fileName = file.name;
                    const baseName = fileName.substring(0, fileName.lastIndexOf('.'));
                    return [
                        '',
                        `echo Processing "${fileName}"...`,
                        `for /f "delims=" %%a in ('ffprobe -v error -show_entries format^=duration -of default^=noprint_wrappers^=1:nokey^=1 "${fileName}"') do (`,
                        '    set "duration_str=%%a"',
                        ')',
                        'for /f "delims=." %%a in ("!duration_str!") do set "duration_int=%%a"',
                        'if !duration_int! equ 0 set "duration_int=10"', // Avoid division by zero for very short videos
                        'set /a "interval = !duration_int! / 10"',
                        'if !interval! equ 0 set "interval=1"', // Ensure at least 1s interval for very short videos
                        'for /l %%i in (1, 1, 10) do (',
                        '    set /a "timestamp = (%%i - 1) * !interval!"',
                        `    echo   - Generating thumbnail %%i for "${fileName}" at !timestamp!s...`,
                        `    ffmpeg -ss !timestamp! -i "${fileName}" -vframes 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" -y "Edit Thumbnails\\${baseName}_%%i.jpg"`,
                        ')'
                    ];
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            document.getElementById('edit-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-edit-script-link').href = URL.createObjectURL(blob);
        }

        window.onload = init;

        function generateFinalBatchScript() {
            const scriptLines = [
                '@echo off',
                'cd /d "%~dp0"',
                'echo Creating output directories...',
                'if not exist "Landscape" mkdir "Landscape"',
                'if not exist "Landscape\\Thumbnails" mkdir "Landscape\\Thumbnails"',
                'if not exist "Landscape Rotate" mkdir "Landscape Rotate"',
                'if not exist "Landscape Rotate\\Thumbnails" mkdir "Landscape Rotate\\Thumbnails"',
                'if not exist "Edit" mkdir "Edit"',
                'if not exist "Edit\\Thumbnails" mkdir "Edit\\Thumbnails"',
                ''
            ];

            const processRenamingAndThumbnails = (videoName, action, destination = '') => {
                const wrapper = Array.from(document.querySelectorAll('.thumbnail-wrapper')).find(w => {
                    const nameDiv = w.querySelector('.thumbnail-name');
                    return nameDiv && nameDiv.dataset.originalFilename.startsWith(videoName);
                });
                
                let originalVideoFile = allVideoFiles.find(f => f.name.startsWith(videoName));
                if (!originalVideoFile) return;

                let currentVideoName = originalVideoFile.name;
                const originalThumbName = originalVideoFile.name.replace(/\.[^/.]+$/, ".jpg");

                if (wrapper) {
                    const nameDiv = wrapper.querySelector('.thumbnail-name');
                    const img = wrapper.querySelector('.thumbnail');
                    const originalFilenameAttr = nameDiv.dataset.originalFilename;
                    const currentFilenameAttr = img.dataset.fileName;

                    if (originalFilenameAttr !== currentFilenameAttr) {
                        const newVideoName = currentFilenameAttr.replace(/\.jpg$/, '.mp4');
                        scriptLines.push(`ren "${currentVideoName}" "${newVideoName}"`);
                        currentVideoName = newVideoName;
                    }
                }
                
                const currentThumbName = currentVideoName.replace(/\.[^/.]+$/, ".jpg");

                switch (action) {
                    case 'move':
                        scriptLines.push(`move /Y "${currentVideoName}" "${destination}\\"`);
                        scriptLines.push(`if exist "Thumbnails\\${originalThumbName}" move /Y "Thumbnails\\${originalThumbName}" "${destination}\\Thumbnails\\${currentThumbName}"`);
                        break;
                    case 'rotate':
                        scriptLines.push(`ffmpeg -i "${currentVideoName}" -vf "transpose=1" "${destination}\\${currentVideoName}"`);
                        scriptLines.push(`del "${currentVideoName}"`);
                        scriptLines.push(`if exist "Thumbnails\\${originalThumbName}" move /Y "Thumbnails\\${originalThumbName}" "${destination}\\Thumbnails\\${currentThumbName}"`);
                        break;
                    case 'delete':
                        scriptLines.push(`del "${currentVideoName}"`);
                        scriptLines.push(`if exist "Thumbnails\\${originalThumbName}" del "Thumbnails\\${originalThumbName}"`);
                        break;
                }
            };

            if (landscapeSelections.size > 0) {
                scriptLines.push('echo Moving landscape files...');
                landscapeSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Landscape'));
                scriptLines.push('');
            }

            if (landscapeRotateSelections.size > 0) {
                scriptLines.push('echo Processing landscape rotate files...');
                landscapeRotateSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'rotate', 'Landscape Rotate'));
                scriptLines.push('');
            }

            if (deleteSelections.size > 0) {
                scriptLines.push('echo Deleting selected files...');
                deleteSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'delete'));
                scriptLines.push('');
            }

            if (editSelections.size > 0) {
                scriptLines.push('echo Moving files to Edit folder...');
                editSelections.forEach(videoName => processRenamingAndThumbnails(videoName, 'move', 'Edit'));
                scriptLines.push('');
            }
            
            scriptLines.push('echo Cleaning up...');
            scriptLines.push('if exist "Edit Thumbnails" (');
            scriptLines.push('    rmdir /S /Q "Edit Thumbnails"');
            scriptLines.push(')');
            scriptLines.push('');
            
            scriptLines.push('echo.');
            scriptLines.push('echo Processing complete.');
            scriptLines.push('pause');

            const script = scriptLines.join('\r\n');
            document.getElementById('final-landscape-batch-script').value = script;
            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            document.getElementById('download-final-landscape-script-link').href = URL.createObjectURL(blob);
        }
        
        window.onload = init;

        document.getElementById('final-landscape-script-modal').querySelector('.close').addEventListener('click', () => {
            document.getElementById('final-landscape-script-modal').style.display = 'none';
        });
        document.getElementById('copy-final-landscape-script-btn').addEventListener('click', () => {
            const scriptTextArea = document.getElementById('final-landscape-batch-script');
            scriptTextArea.select();
            navigator.clipboard.writeText(scriptTextArea.value).then(() => {
                alert('Script copied to clipboard!');
                document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
            });
        });

        document.getElementById('download-final-landscape-script-link').addEventListener('click', () => {
            document.getElementById('reload-final-script-page-btn').style.display = 'inline-block';
        });

        document.getElementById('reload-final-script-page-btn').addEventListener('click', () => {
            location.reload();
        });

        function generateBatchScript(videoFiles, dirName) {
            const scriptLines = [
                '@echo off',
                `cd /d "%~dp0"`,
                'echo Creating Thumbnails directory...',
                'if not exist "Thumbnails" mkdir Thumbnails',
                'echo Generating thumbnails...',
                ...videoFiles.map(file => {
                    const fileName = file.name;
                    const thumbnailName = fileName.substring(0, fileName.lastIndexOf('.')) + '.jpg';
                    return `ffmpeg -y -i "${fileName}" -ss 00:00:02.000 -frames:v 1 -vf "scale=256:256:force_original_aspect_ratio=decrease" "Thumbnails\\${thumbnailName}"`;
                }),
                'echo.',
                'echo Thumbnail generation complete.',
                'pause'
            ];
            const script = scriptLines.join('\r\n');
            batchScriptTextArea.value = script;

            const blob = new Blob([script], { type: 'text/plain;charset=utf-8' });
            downloadScriptLink.href = URL.createObjectURL(blob);
        }

        function copyScriptToClipboard() {
            batchScriptTextArea.select();
            navigator.clipboard.writeText(batchScriptTextArea.value).then(() => {
                alert('Script copied to clipboard! Paste it into a file named "generate_thumbnails.bat" in your video folder and run it.');
                reloadPageBtn.style.display = 'inline-block';
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function downloadBatchFile() {
            alert('Once downloaded, move the ".bat" file into your video folder and double-click it to run.');
            reloadPageBtn.style.display = 'inline-block';
        }

        reloadPageBtn.addEventListener('click', () => {
            location.reload();
        });
        
        function initializeFilenameBuilder() {
            filenamePartsContainer.innerHTML = '';
            // Start with a category and one element
            filenameParts = [{ type: 'category', value: '' }, { type: 'element', value: '' }];
            renderFilenameParts();
            updateFilenamePreview();
            populatePreviousElements();
            populatePreviousCategories();
        }

        function renderFilenameParts() {
            filenamePartsContainer.innerHTML = '';
            filenameParts.forEach((part, index) => {
                const row = document.createElement('div');
                row.className = 'filename-part-row';

                const input = document.createElement('input');
                input.type = 'text';
                input.value = part.value;

                if (part.type === 'category') {
                    input.placeholder = 'Category';
                    input.setAttribute('list', 'previous-categories-list');
                } else {
                    input.placeholder = `Element ${index}`;
                    input.setAttribute('list', 'previous-elements-list');
                }

                input.addEventListener('input', () => {
                    part.value = input.value;
                    updateFilenamePreview();
                });

                row.appendChild(input);

                if (index > 0) { // Can't remove the 'Category'
                    const removeBtn = document.createElement('button');
                    removeBtn.textContent = '-';
                    removeBtn.onclick = () => removeFilenamePart(index);
                    row.appendChild(removeBtn);
                }
                filenamePartsContainer.appendChild(row);
            });
        }

        function updateFilenamePreview() {
            const username = projectUsernameInput.value || 'username';
            const category = filenameParts[0]?.value.trim() || 'Category';
            
            const elements = filenameParts.slice(1)
                .map(p => p.value.trim())
                .filter(p => p);

            // Build a representative filename string for the preview
            const elementsString = elements.map(e => `(${e})`).join(' ');
            filenamePreview.textContent = `[${username}]_${category} ${elementsString} (1).mp4`;

            // Also show the final button text and structure
            if (elements.length > 0) {
                const buttonName = elements[elements.length - 1];
                let structure = category;
                if (elements.length > 1) {
                    structure += ` -> ${elements.slice(0, -1).join(' -> ')}`;
                }
                filenamePreview.textContent += `\nButton: "${buttonName}" under "${structure}"`;
            }
        }

        function addFilenamePart(value = '') {
            filenameParts.push({ type: 'element', value });
            renderFilenameParts();
            updateFilenamePreview();
        }

        function removeFilenamePart(index) {
            if (filenameParts.length > 2) { // Always keep at least one category and one element
                filenameParts.splice(index, 1);
                renderFilenameParts();
                updateFilenamePreview();
            }
        }

        function getPreviousElements() {
            return JSON.parse(localStorage.getItem('previousFilenameElements') || '[]');
        }

        function populatePreviousElements() {
            const values = getPreviousElements();
            const datalist = document.getElementById('previous-elements-list');
            datalist.innerHTML = '';
            values.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        function getPreviousCategories() {
            return JSON.parse(localStorage.getItem('previousFilenameCategories') || '[]');
        }

        function populatePreviousCategories() {
            const categories = getPreviousCategories();
            const datalist = document.getElementById('previous-categories-list');
            datalist.innerHTML = '';
            categories.forEach(val => {
                const option = document.createElement('option');
                option.value = val;
                datalist.appendChild(option);
            });
        }

        document.getElementById('add-element-btn').addEventListener('click', () => addFilenamePart());

        createFilenameButtonBtn.addEventListener('click', () => {
            const category = filenameParts[0]?.value.trim();
            if (!category) {
                alert('A "Category" is required to create a button.');
                return;
            }

            const elements = filenameParts.slice(1).map(p => p.value.trim()).filter(p => p);
            if (elements.length === 0) {
                alert('At least one "Element" is required to create a button.');
                return;
            }
            
            // --- Save values to localStorage for future suggestions ---
            const previousElements = getPreviousElements();
            elements.forEach(el => {
                if (el && !previousElements.includes(el)) previousElements.push(el);
            });
            localStorage.setItem('previousFilenameElements', JSON.stringify(previousElements));

            const previousCategories = getPreviousCategories();
            if (category && !previousCategories.includes(category)) {
                previousCategories.push(category);
                localStorage.setItem('previousFilenameCategories', JSON.stringify(previousCategories));
            }

            // --- Construct button data and save to the main tree ---
            let customButtonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');
            
            const path = [category, ...elements];
            const buttonData = {
                fullButtonText: elements.map(p => `(${p})`).join(' ')
            };

            if (insertButtonIntoTree(customButtonTree, path, buttonData)) {
                localStorage.setItem(`${directoryName}-customButtons`, JSON.stringify(customButtonTree));
                loadCustomButtons();
                filenameBuilderModal.style.display = 'none';
                populatePreviousElements(); // Refresh datalists for next time
                populatePreviousCategories();
            } else {
                alert('A button with this exact name and category structure already exists.');
            }
        });

        async function loadCustomButtons() {
            if (!directoryName) {
                return;
            }
            const scrollContainer = document.getElementById('sidebar-scroll-container');
            scrollContainer.innerHTML = '';
            let customButtonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');
            const collapseState = JSON.parse(localStorage.getItem(`${directoryName}-collapseState`) || '{}');
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);
            const buttonVisibility = JSON.parse(localStorage.getItem(`${directoryName}-buttonVisibility`) || '{}');


            const createCollapseClickHandler = (key) => (event) => {
                event.stopPropagation();
                let collapseState = JSON.parse(localStorage.getItem(`${directoryName}-collapseState`) || '{}');
                collapseState[key] = !collapseState[key];
                localStorage.setItem(`${directoryName}-collapseState`, JSON.stringify(collapseState));
                loadCustomButtons();
            };

            function renderTree(nodes, parentContainer, level, parentPath) {
                if (!Array.isArray(nodes)) return;

                // Sort all nodes alphabetically. Special case for '+1' button to always be first.
                nodes.sort((a, b) => {
                    if (a.name === '+1') return -1;
                    if (b.name === '+1') return 1;
                    return a.name.localeCompare(b.name);
                });

                nodes.forEach(node => {
                    const currentPath = [...parentPath, node.name];
                    const nodeKey = `node_${currentPath.join('_')}`;

                    if (node.type === 'category' && level < numElements) {
                        const isCollapsed = collapseState[nodeKey] || false;
                        const header = document.createElement(`h${4 + level}`);
                        header.textContent = currentPath.join('-');
                        header.style.marginLeft = `${level * 8}px`;
                        header.style.cursor = 'pointer';
                        header.onclick = createCollapseClickHandler(nodeKey);
                        parentContainer.appendChild(header);

                        if (!isCollapsed && Array.isArray(node.children)) {
                            renderTree(node.children, parentContainer, level + 1, currentPath);
                        }
                    } else {
                        function createButtonsFromSubtree(startingNode, basePath, textParts) {
                            if (startingNode.type === 'button') {
                                if (buttonVisibility[startingNode.id] === false) return;
                                
                                const combinedName = [...textParts, startingNode.name].join(' ');
                                const finalButtonName = startingNode.specialType === 'plusOne' ? '+1' : combinedName;
                                
                                parentContainer.appendChild(createSidebarButton({ ...startingNode, name: finalButtonName }, basePath));

                            } else if (startingNode.type === 'category' && Array.isArray(startingNode.children)) {
                                const newTextParts = [...textParts, startingNode.name];
                                startingNode.children.forEach(child => {
                                    createButtonsFromSubtree(child, basePath, newTextParts);
                                });
                            }
                        }
                        // By passing an empty array `[]` as the initial textParts, we prevent the
                        // duplication bug where the starting node's name was added twice. The
                        // recursive function is responsible for building the entire name string.
                        createButtonsFromSubtree(node, currentPath.slice(0, numElements), []);
                    }
                });
            }

            renderTree(customButtonTree, scrollContainer, 0, []);
        }

    function populateVisibleButtonsModal() {
        visibleButtonsListContainer.innerHTML = '';
        let customButtonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');
        const buttonVisibility = JSON.parse(localStorage.getItem(`${directoryName}-buttonVisibility`) || '{}');
        const numElements = parseInt(document.getElementById('num-elements-input').value, 10);

        // We'll use a modified render function to build the checklist
        function renderVisibilityChecklist(nodes, parentContainer, level, parentPath = []) {
            if (!Array.isArray(nodes)) return;

            // Use the same sorting as the main render function
            nodes.sort((a, b) => {
                if (a.name === '+1') return -1;
                if (b.name === '+1') return 1;
                if (a.type === 'category' && b.type !== 'category') return -1;
                if (a.type !== 'category' && b.type === 'category') return 1;
                return a.name.localeCompare(b.name);
            });

            nodes.forEach(node => {
                const currentPath = [...parentPath, node.name];
                if (node.type === 'category' && level <= numElements) {
                    const header = document.createElement(`h${4 + level}`);
                    header.textContent = currentPath.join('-');
                    header.style.marginLeft = `${level * 8}px`;
                    header.style.color = 'black';
                    parentContainer.appendChild(header);
                    
                    const childrenContainer = document.createElement('div');
                    renderVisibilityChecklist(node.children, childrenContainer, level + 1);
                    parentContainer.appendChild(childrenContainer);

                } else {
                     function createCheckboxesFromSubtree(startingNode, textParts) {
                        if (startingNode.type === 'button') {
                            const allTextParts = [...textParts, startingNode.name];
                            const buttonName = startingNode.specialType === 'plusOne' 
                                ? '+1'
                                : allTextParts.filter(p => p !== '+1').join(' ');
                            
                            const div = document.createElement('div');
                            div.style.marginLeft = `${(numElements + 1) * 8}px`;
                            div.style.display = 'flex';
                            div.style.alignItems = 'center';

                            const checkbox = document.createElement('input');
                            checkbox.type = 'checkbox';
                            checkbox.id = `vis-check-${startingNode.id}`;
                            checkbox.checked = buttonVisibility[startingNode.id] !== false; // Default to visible
                            
                            checkbox.onchange = () => {
                                buttonVisibility[startingNode.id] = checkbox.checked;
                                localStorage.setItem(`${directoryName}-buttonVisibility`, JSON.stringify(buttonVisibility));
                                loadCustomButtons(); // Re-render the main sidebar
                            };

                            const label = document.createElement('label');
                            label.htmlFor = checkbox.id;
                            label.textContent = buttonName;
                            label.style.color = 'black';
                            label.style.marginLeft = '4px';

                            div.appendChild(checkbox);
                            div.appendChild(label);
                            parentContainer.appendChild(div);

                        } else if (startingNode.type === 'category') {
                            const newTextParts = [...textParts, startingNode.name];
                            if(Array.isArray(startingNode.children)) {
                                startingNode.children.forEach(child => createCheckboxesFromSubtree(child, newTextParts));
                            }
                        }
                    }
                    createCheckboxesFromSubtree(node, []);
                }
            });
        }

        renderVisibilityChecklist(customButtonTree, visibleButtonsListContainer, 0, []);
    }

    visibleButtonsBtn.addEventListener('click', () => {
        populateVisibleButtonsModal();
        visibleButtonsModal.style.display = 'block';
    });

    visibleButtonsModal.querySelector('.close').addEventListener('click', () => {
        visibleButtonsModal.style.display = 'none';
    });

        function updateBottomBar() {
            const infoDiv = document.getElementById('bottom-bar-info');
            if (buttonsForRemoval.size === 1) {
                const buttonId = buttonsForRemoval.values().next().value;
                let customButtonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');

                function findButtonPath(nodes, id, currentPath = []) {
                    for (const node of nodes) {
                        if (node.type === 'button' && String(node.id) === String(id)) {
                            return { button: node, path: currentPath };
                        }
                        if (node.type === 'category' && node.children) {
                            const result = findButtonPath(node.children, id, [...currentPath, node.name]);
                            if (result) {
                                return result;
                            }
                        }
                    }
                    return null;
                }
                
                const result = findButtonPath(customButtonTree, buttonId);

                if (result && result.path.length > 0) {
                    const username = projectUsernameInput.value.trim() || 'username';
                    const category = result.path[0];
                    const fullButtonText = result.button.fullButtonText;
                    infoDiv.textContent = `[${username}]_${category} ${fullButtonText}`;
                } else {
                    infoDiv.textContent = '1 item selected';
                }

            } else if (buttonsForRemoval.size > 1) {
                infoDiv.textContent = `${buttonsForRemoval.size} items selected`;
            } else {
                infoDiv.textContent = '';
            }
        }

        function createSidebarButton(buttonData, path) {
            const { id, name, fullButtonText, specialType } = buttonData;
            
            const button = document.createElement('button');
            button.textContent = name.replace(/[()]/g, ''); // Remove parentheses for display
            button.dataset.id = id;
            const numElements = parseInt(document.getElementById('num-elements-input').value, 10);
            button.style.paddingLeft = `${(numElements) * 8}px`; // Indent based on hierarchy depth

            // Preserve selection state across re-renders
            if (buttonsForRemoval.has(String(id))) {
                button.classList.add('selected-for-removal');
            }

            button.onclick = () => {
                const buttonId = button.dataset.id;
                const isCurrentlySelected = button.classList.contains('selected-for-removal');

                if (isCurrentlySelected) {
                    buttonsForRemoval.delete(buttonId);
                    button.classList.remove('selected-for-removal');
                } else {
                    buttonsForRemoval.add(buttonId);
                    button.classList.add('selected-for-removal');
                }
                updateRemoveButtonState();
                updateBottomBar();
                
                // For '+1' buttons, we highlight differently
                if (specialType === 'plusOne') {
                    highlightMatchingThumbnails(path, '', !isCurrentlySelected, true);
                } else {
                    highlightMatchingThumbnails(path, fullButtonText, !isCurrentlySelected, false);
                }
            };

            const fontSize = document.getElementById('font-size-slider').value;
            button.style.cssText += `
                width: 100%; margin: 0; padding-top: 0; padding-bottom: 0; height: 36px;
                background-color: #1877f2; color: #ffffff; border: 1px solid #444444;
                border-top: none; border-radius: 0; font-size: ${fontSize}px; cursor: pointer;
                box-sizing: border-box; text-align: left; display: block;
            `;
            button.style.textAlign = 'left';
            
            adjustButtonFontSize(button);
            return button;
        }

        function highlightMatchingThumbnails(path, fullButtonText, shouldSelect, isCategoryOnly) {
            const username = projectUsernameInput.value.trim();
            if (!username) return;

            const category = path[0];
            const prefix = `[${username}]_${category}`;

            const currentCanvas = canvases.get(activeCanvasId);
            if (currentCanvas) {
                currentCanvas.thumbnails.forEach(thumb => {
                    const baseFilename = thumb.dataset.fileName.substring(0, thumb.dataset.fileName.lastIndexOf('.'));
                    const filenameWithoutNumber = baseFilename.replace(/\s*\(\d+\)$/, '').trim();
                    
                    let matches = false;
                    if (isCategoryOnly) {
                        // For +1, we want an exact match with the prefix, and nothing after it.
                        matches = filenameWithoutNumber === prefix;
                    } else {
                        // For regular buttons, it must start with the prefix and contain the elements.
                        const expectedFilenamePart = `${prefix} ${fullButtonText}`;
                        matches = filenameWithoutNumber.startsWith(expectedFilenamePart);
                    }

                    if (matches) {
                        if (shouldSelect) {
                            if (!selectedThumbnails.has(thumb)) {
                                thumb.classList.add('selected');
                                selectedThumbnails.add(thumb);
                            }
                        } else {
                            if (selectedThumbnails.has(thumb)) {
                                thumb.classList.remove('selected');
                                selectedThumbnails.delete(thumb);
                            }
                        }
                    }
                });
            }
            updatePlayButtonState();
        }

        function adjustButtonFontSize(button) {
            const fontSize = document.getElementById('font-size-slider').value;
            button.style.fontSize = `${fontSize}px`;
        }

        newFilenameBtn.addEventListener('click', () => {
            filenameBuilderModal.style.display = 'block';
            initializeFilenameBuilder();
        });

        removeBtn.addEventListener('click', () => {
            if (buttonsForRemoval.size === 0) {
                alert('Please select one or more buttons to remove.');
                return;
            }

            if (confirm(`Are you sure you want to remove ${buttonsForRemoval.size} button(s)?`)) {
                let buttonTree = JSON.parse(localStorage.getItem(`${directoryName}-customButtons`) || '[]');
                
                function removeButtonsFromTree(nodes) {
                    if (!Array.isArray(nodes)) return [];
                    
                    // Filter out leaf buttons that should be removed
                    let filteredNodes = nodes.filter(node => {
                        return !(node.type === 'button' && buttonsForRemoval.has(String(node.id)));
                    });

                    // Recurse into remaining category nodes
                    return filteredNodes.map(node => {
                        if (node.type === 'category' && node.children) {
                            node.children = removeButtonsFromTree(node.children);
                        }
                        return node;
                    // After removing children, a category might become empty. Remove it.
                    }).filter(node => !(node.type === 'category' && (!node.children || node.children.length === 0)));
                }
                
                const newButtonTree = removeButtonsFromTree(buttonTree);
                localStorage.setItem(`${directoryName}-customButtons`, JSON.stringify(newButtonTree));

                buttonsForRemoval.clear();
                loadCustomButtons();
                updateRemoveButtonState();
            }
        });

        filenameBuilderModal.querySelector('.close').addEventListener('click', () => {
            filenameBuilderModal.style.display = 'none';
        });

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            let mouseDownEvent = null;

            element.addEventListener('dragstart', (e) => e.preventDefault());
            element.onmousedown = dragMouseDown;

            function dragMouseDown(e) {
                e = e || window.event;
                e.preventDefault();
                isDragging = false;
                mouseDownEvent = e;

                pos3 = e.clientX;
                pos4 = e.clientY;

                if (!isLayoutFrozen) {
                    freezeLayout();
                }

                if (selectedThumbnails.has(element)) {
                    selectedThumbnails.forEach(thumb => {
                        thumb.style.zIndex = zIndexCounter++;
                    });
                } else {
                    element.style.zIndex = zIndexCounter++;
                }
                
                document.onmouseup = closeDragElement;
                document.onmousemove = elementDrag;
            }

            function elementDrag(e) {
                isDragging = true;
                e = e || window.event;
                e.preventDefault();

                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;

                if (selectedThumbnails.has(element)) {
                    selectedThumbnails.forEach(thumb => {
                        const containerRect = thumbnailContainer.getBoundingClientRect();
                        const elementRect = thumb.getBoundingClientRect();
                        
                        let newTop = thumb.offsetTop - pos2;
                        let newLeft = thumb.offsetLeft - pos1;

                        if (newLeft < 0) newLeft = 0;
                        if (newTop < 0) newTop = 0;
                        
                        thumb.style.top = newTop + "px";
                        thumb.style.left = newLeft + "px";
                    });
                } else {
                    const containerRect = thumbnailContainer.getBoundingClientRect();
                    const elementRect = element.getBoundingClientRect();
                    
                    let newTop = element.offsetTop - pos2;
                    let newLeft = element.offsetLeft - pos1;

                    if (newLeft < 0) newLeft = 0;
                    if (newTop < 0) newTop = 0;
                    
                    element.style.top = newTop + "px";
                    element.style.left = newLeft + "px";
                }
            }

            function closeDragElement() {
                 if (!isDragging) {
                    const wrapper = element;
                    const clickEvent = mouseDownEvent;
                    if (isMultiSelectMode || clickEvent.ctrlKey || clickEvent.metaKey) {
                        if (selectedThumbnails.has(wrapper)) {
                            wrapper.classList.remove('selected');
                            selectedThumbnails.delete(wrapper);
                        } else {
                            wrapper.classList.add('selected');
                            selectedThumbnails.add(wrapper);
                        }
                    } else {
                        selectedThumbnails.forEach(t => t.classList.remove('selected'));
                        selectedThumbnails.clear();
                        wrapper.classList.add('selected');
                        selectedThumbnails.add(wrapper);
                    }
                    updatePlayButtonState();
                }

                document.onmouseup = null;
                document.onmousemove = null;

                const canvasData = {
                    canvases: Array.from(canvases.values()).map(c => ({
                        id: c.id,
                        name: c.name,
                        thumbnails: c.thumbnails.map(t => ({
                            fileName: t.dataset.fileName,
                            left: t.style.left,
                            top: t.style.top,
                            previousCanvasId: t.dataset.previousCanvasId
                        }))
                    })),
                    activeCanvasId: activeCanvasId
                };
                localStorage.setItem(`${directoryName}-canvasData`, JSON.stringify(canvasData));
                updateContentSpacer();
            }
        }

        function freezeLayout() {
            const wrappers = thumbnailContainer.querySelectorAll('.thumbnail-wrapper');
            if (wrappers.length === 0) return;

            const positions = [];
            wrappers.forEach(wrapper => {
                positions.push({
                    left: wrapper.offsetLeft,
                    top: wrapper.offsetTop
                });
            });

            wrappers.forEach((wrapper, index) => {
                wrapper.style.position = 'absolute';
                wrapper.style.left = positions[index].left + 'px';
                wrapper.style.top = positions[index].top + 'px';
            });
            
            isLayoutFrozen = true;
            updateContentSpacer();
        }

        function sortThumbnails(sortBy) {
            const canvas = canvases.get(activeCanvasId);
            if (!canvas) return;

            isLayoutFrozen = false; 
            
            if (sortBy === 'name') {
                canvas.thumbnails.sort((a, b) => a.dataset.fileName.localeCompare(b.dataset.fileName));
            } else if (sortBy === 'random') {
                canvas.thumbnails.sort(() => Math.random() - 0.5);
            }

            renderCanvas(activeCanvasId);
        }

        function saveLayout() {
            const layoutName = layoutNameInput.value.trim();
            if (!layoutName) {
                alert('Please enter a name for the layout.');
                layoutNameInput.focus();
                return;
            }
            if (!isLayoutFrozen) {
                alert('Please move at least one thumbnail before saving the layout.');
                return;
            }

            const thumbnails = document.querySelectorAll('.thumbnail');
            const layoutData = {
                positions: {},
                size: sizeSelector.value
            };
            thumbnails.forEach(thumb => {
                layoutData.positions[thumb.dataset.fileName] = {
                    left: thumb.style.left,
                    top: thumb.style.top
                };
            });
            
            const layouts = JSON.parse(localStorage.getItem(`${directoryName}-layouts`) || '{}');
            layouts[layoutName] = layoutData;
            localStorage.setItem(`${directoryName}-layouts`, JSON.stringify(layouts));
            
            layoutNameInput.value = '';
            populateLayoutsDropdown();
            alert(`Layout "${layoutName}" saved!`);
        }

        layoutNameInput.addEventListener('input', () => {
            if (layoutNameInput.value.trim() !== '') {
                saveLayoutBtn.textContent = 'Save Layout';
            }
        });

        function loadLayout() {
            const selectedValue = layoutSelect.value;
            if (!selectedValue) return;

            if (selectedValue.startsWith('scan_')) {
                const layoutName = selectedValue.replace('scan_', '');
                const layoutData = scanLayouts[layoutName];
                if (layoutData) {
                    applyScanLayout(layoutData);
                }
                return;
            }

            const layouts = JSON.parse(localStorage.getItem(`${directoryName}-layouts`) || '{}');
            const layoutData = layouts[selectedValue];
            
            if (!layoutData) return;

            if (!isLayoutFrozen) {
                freezeLayout();
            }
            
            sizeSelector.value = layoutData.size;
            applyThumbnailSize();

            const thumbnails = document.querySelectorAll('.thumbnail');
            thumbnails.forEach(thumb => {
                const pos = layoutData.positions[thumb.dataset.fileName];
                if (pos) {
                    thumb.style.left = pos.left;
                    thumb.style.top = pos.top;
                }
            });
            updateContentSpacer();
        }

        function deleteLayout() {
            const layoutName = layoutSelect.value;
            if (!layoutName) {
                alert('Please select a layout to delete.');
                return;
            }
            if (confirm(`Are you sure you want to delete the "${layoutName}" layout?`)) {
                const layouts = JSON.parse(localStorage.getItem(`${directoryName}-layouts`) || '{}');
                delete layouts[layoutName];
                localStorage.setItem(`${directoryName}-layouts`, JSON.stringify(layouts));
                populateLayoutsDropdown();
            }
        }

        function applyScanLayout(layoutData) {
            if (!isLayoutFrozen) {
                freezeLayout();
            }

            const allThumbs = Array.from(document.querySelectorAll('.thumbnail'));
            const thumbMap = new Map(allThumbs.map(t => [t.dataset.fileName, t]));
            const groupedThumbs = new Set();
            let currentY = 0;

            // Sort groups by header name
            layoutData.sort((a, b) => a.Header.localeCompare(b.Header));

            layoutData.forEach(group => {
                if (group.IsGroup) {
                    let currentX = 0;
                    let maxRowHeight = 0;

                    group.AllChildren.forEach(child => {
                        const pathParts = child.Item.ItemInfo.Path.split('\\');
                        const videoFilename = pathParts[pathParts.length - 1];
                        const thumbFilename = videoFilename.substring(0, videoFilename.lastIndexOf('.')) + '.jpg';
                        
                        const thumb = thumbMap.get(thumbFilename);
                        if (thumb) {
                            if (currentX + thumb.offsetWidth > thumbnailContainer.clientWidth) {
                                currentX = 0;
                                currentY += maxRowHeight + 20; // 20px vertical gap
                                maxRowHeight = 0;
                            }
                            thumb.style.left = currentX + 'px';
                            thumb.style.top = currentY + 'px';
                            currentX += thumb.offsetWidth + 20; // 20px horizontal gap
                            if (thumb.offsetHeight > maxRowHeight) {
                                maxRowHeight = thumb.offsetHeight;
                            }
                            groupedThumbs.add(thumb);
                        }
                    });
                     if (group.AllChildren.length > 0) {
                        currentY += maxRowHeight + (thumbMap.values().next().value?.offsetHeight || 200);
                    }
                }
            });

            // Handle ungrouped thumbnails
            let currentX = 0;
            let maxRowHeight = 0;
            allThumbs.forEach(thumb => {
                if (!groupedThumbs.has(thumb)) {
                    if (currentX + thumb.offsetWidth > thumbnailContainer.clientWidth) {
                        currentX = 0;
                        currentY += maxRowHeight + 20;
                        maxRowHeight = 0;
                    }
                    thumb.style.left = currentX + 'px';
                    thumb.style.top = currentY + 'px';
                    currentX += thumb.offsetWidth + 20;
                    if (thumb.offsetHeight > maxRowHeight) {
                        maxRowHeight = thumb.offsetHeight;
                    }
                }
            });

            updateContentSpacer();
        }

        function populateLayoutsDropdown() {
            const savedLayouts = JSON.parse(localStorage.getItem(`${directoryName}-layouts`) || '{}');
            const savedLayoutNames = Object.keys(savedLayouts);
            const scanLayoutNames = Object.keys(scanLayouts);

            layoutSelect.innerHTML = '<option value="" disabled hidden>Select Layout</option>';

            const landscapeOption = document.createElement('option');
            landscapeOption.value = 'widescreen_rotate';
            landscapeOption.textContent = 'Widescreen/Rotate';
            layoutSelect.appendChild(landscapeOption);

            if (scanLayoutNames.length > 0) {
                const scanGroup = document.createElement('optgroup');
                scanGroup.label = 'Scan Layouts';
                scanLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = `scan_${name}`;
                    option.textContent = name;
                    scanGroup.appendChild(option);
                });
                layoutSelect.appendChild(scanGroup);
            }

            if (savedLayoutNames.length > 0) {
                const savedGroup = document.createElement('optgroup');
                savedGroup.label = 'Saved Layouts';
                savedLayoutNames.forEach(name => {
                    const option = document.createElement('option');
                    option.value = name;
                    option.textContent = name;
                    savedGroup.appendChild(option);
                });
                layoutSelect.appendChild(savedGroup);
            }
        }

        function startSelection(e) {
            if (e.target !== thumbnailContainer) return;
            e.preventDefault();

            const containerRect = thumbnailContainer.getBoundingClientRect();
            let startX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
            let startY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

            selectionBox.style.left = startX + 'px';
            selectionBox.style.top = startY + 'px';
            selectionBox.style.width = '0px';
            selectionBox.style.height = '0px';
            selectionBox.style.display = 'block';

            document.addEventListener('mousemove', handleSelection);
            document.addEventListener('mouseup', endSelection);

            function handleSelection(e) {
                let currentX = e.clientX - containerRect.left + thumbnailContainer.scrollLeft;
                let currentY = e.clientY - containerRect.top + thumbnailContainer.scrollTop;

                let newLeft = Math.min(startX, currentX);
                let newTop = Math.min(startY, currentY);
                let newWidth = Math.abs(startX - currentX);
                let newHeight = Math.abs(startY - currentY);

                selectionBox.style.left = newLeft + 'px';
                selectionBox.style.top = newTop + 'px';
                selectionBox.style.width = newWidth + 'px';
                selectionBox.style.height = newHeight + 'px';
            }

            function endSelection(e) {
                document.removeEventListener('mousemove', handleSelection);
                document.removeEventListener('mouseup', endSelection);
                
                selectThumbnailsInBox();
                selectionBox.style.display = 'none';
            }
        }

        function selectThumbnailsInBox() {
            const boxRect = selectionBox.getBoundingClientRect();
            const thumbnails = document.querySelectorAll('.thumbnail');

            if (!isMultiSelectMode) {
                selectedThumbnails.forEach(t => t.classList.remove('selected'));
                selectedThumbnails.clear();
            }
            
            thumbnails.forEach(thumb => {
                const thumbRect = thumb.getBoundingClientRect();
                
                if (
                    boxRect.left < thumbRect.right &&
                    boxRect.right > thumbRect.left &&
                    boxRect.top < thumbRect.bottom &&
                    boxRect.bottom > thumbRect.top
                ) {
                    if (!selectedThumbnails.has(thumb)) {
                       thumb.classList.add('selected');
                       selectedThumbnails.add(thumb);
                    }
                }
            });
            updatePlayButtonState();
        }

        const resizer = document.getElementById('sidebar-resizer');
        const sidebar = document.getElementById('sidebar');

        resizer.addEventListener('mousedown', (e) => {
            e.preventDefault();

            const handleMouseUp = () => {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);

                // Adjust font size for all buttons after resizing
                const buttons = document.querySelectorAll('#sidebar-scroll-container button');
                buttons.forEach(button => adjustButtonFontSize(button));
            };

            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        });

        function handleMouseMove(e) {
            const newWidth = e.clientX;
            if (newWidth > 100 && newWidth < 500) { // Min and max width
                sidebar.style.width = newWidth + 'px';
            }
        }
    </script>
</body>
</html>
